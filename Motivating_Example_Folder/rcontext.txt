1 Introduction
Software developers are increasingly integrating machine learning
(ML) into systems using ML libraries’ application programming
interfaces (APIs). However, ML software is bug-prone (Zhang et al.
2018b; Islam et al. 2019; Humbatova et al. 2020) and like traditional
software could benefit from adopting a design-by-contract
methodology (Islam et al. 2019). Contracts can specify the expected
behavior of an API and help client code use the API correctly, e.g., a
contract might require that the fit method be applied to a model
before calling the predict method. Another example can be given
using the MaxPooling2D method for retaining the most prominent
features of the feature map in a convolutional neural network
(CNN). There is a contract on the MaxPooling2D method’s
argument, data_format, based on the shape of the input image. If
the input image has the shape (N, C, H, W), then the value for the
argument data_format is set to channels_first. If the input has the
shape (N, H, W, C), then data_format must be set to channels_last.
Here, the letters N, H, W, and C represent the following: the
number of images in the batch, the height of the image, the width
of the image, and the number of channels of the image.
There is a rich body of prior work that can be grouped into two
categories: work on contracts for non-ML software and work on ML
software.
The first category, contracts for non-ML software, can be further
divided into two types: behavioral and temporal. Behavioral
contracts (Hoare 1969; Meyer 1988; Pradel and Gross 2009;
Pǎsăreanu and Rungta 2010; Nguyen et al. 2014; Khairunnesa et al.
2017) specify acceptable program states, typically for calls to
individual methods in an API. For instance, in the Java Development
Kit (JDK) String class, the precondition ‘beginIndex<=endIndex’
must be true before calling method
subString(beginIndex,endIndex). The contracts that belong to this
category are preconditions (as in the example), or postconditions
(constraints ensured by the execution of the call) for a method in
question. There are also class invariants that capture the
constraints for all methods in a particular class. Temporal contracts
(Manna and Pnueli 1992; Gruska et al. 2010; Nguyen et al. 2009;
Wasylkowski et al. 2007) encode the correct ordering of calls,
possibly among multiple APIs. For example, in Python, after
creating a threading.Lock object, once a thread makes a call to
Lock.acquire(), that thread should eventually call Lock.release().
The notion of contracts in this study is similar to the kinds of
contracts described just before this phrase. We have used the same
definition of (behavioral and temporal) contracts in this study. A
contract specifies the correct usage of an API and an incorrect usage
is a contract violation.
The second category is about ML software and its bugs (Zhang et al.
2018b; Islam et al. 2019; Humbatova et al. 2020) and bug fixes (Sun
et al. 2017; Islam et al. 2020). These works study either the
implementation of ML library APIs or usage information about
those APIs. Zhang et al. (2018b) and Humbatova et al. (2020)
focused on understanding the defects in different ML libraries. The
authors (Zhang et al. 2018b) noted that the defect might come from
various sources, e.g., program code, execution environment, library
framework itself, etc. In contrast, the focus of this study is to gain
an understanding of ML API contracts. Islam et al. (2019) reported
on API misuse. API misuse can be detected if contract obligations
are specified. Sun et al. (2017) investigated the issues in various ML
libraries to understand the bug-fix patterns in these libraries,
whereas Islam et al. (2020) studied the deep neural network (DNN)
models to understand the bug-fix patterns. In our study, we
focused on ML API contracts and corresponding breaches. Suppose
a user maintains a contract obligation for an ML API. In that case, if
the API demonstrates exceptional behavior upon exiting, the issue
may be present in the implementation of the API.
Our work focuses on investigating the kinds of contracts required to
establish the correct usage of ML APIs. The main question is: what
are the kinds of contracts required to establish the correct usage of ML
APIs? We observe that ML software is different from traditional
software in several ways. In ML software, problem-solving is
largely dependent on training data and subject to precise settings of
hyper-parameters (Zhang et al. 2018b). A prior work by Humbatova
et al. (2020) suggested that choice of loss function/optimizer,
missing/redundant/wrong layers, etc. are distinctive bugs in ML
software. Also, incorrect use of ML APIs may not always lead to
crashes, but may instead lead to slower performance or statistically
invalid results. In this study, we did not aim to check the reliability
of the ML systems. Instead, we looked at the errors occurring in ML
programs due to the incorrect usage of ML APIs.
We studied four popular ML libraries: TensorFlow, Scikit-learn,
Kerasand PyTorch and studied posts from the Q &A forum Stack
Overflow (SO) that contain one of these libraries in a tag. The dataset
(labeled SO posts, queries, source codes, etc.) generated during our
study are available in the figshare repository,
https://figshare.com/s/c288c02598a417a434df. This dataset
includes a total of 1565 posts, from which we manually curated
posts that hold 413 contracts for relevant ML APIs. We use this data
to answer the following research questions:
RQ1 (Root Cause and Effect): What are the root causes and effects
behind ML contract violations?
RQ2 (Patterns): Are there common patterns of ML contract
violations?
RQ3 (Contract Comprehension Challenges): When does
understanding ML contracts require an advanced level of ML
software expertise?
RQ4 (Contract Violation Detection): Can checking contracts at the
API level help detect the violation in early ML pipeline stages?
These questions, and the data that support their answers, help to
answer the main question, i.e., they enable researchers and
practitioners to pinpoint where immediate support is required in
terms of contracts for ML APIs. The key findings from our study are
summarized in Table 1.
Table 1 Findings and Insights
Full size table
The contributions of our paper are the following. We provide a
taxonomy for ML API contracts and corresponding root causes.
This taxonomy (§2.3) added five new leaf node categories of
contracts (with respect to the leaf categories observed in traditional
behavioral and temporal contracts) observed in our study. The work
also identified the stages of ML pipelines in which the violations
occur (API contract violation locations) or affect the software and
presented a dedicated classification (§2.4). To our knowledge, this
is the first work that attempts to understand the types of required
contracts needed to prevent problems that may arise when using
these ML APIs in software systems. In §3, in addition to answering
the research questions, we analyze the outcomes related to contract
breaches. Finally, we provide recommendations to researchers,
consumers, and producers of ML APIs based on the findings.
2 Methodology
2.1 Overview
In this study, we used Stack Overflow (SO) to investigate API
contracts’ requirements for the most-asked about and widely-used
ML libraries and frameworks. SO is a forum for software
development professionals and enthusiasts. In recent years SO has
served as an open repository for conducting studies on software
engineering topics (Zhang et al. 2018a; Cai et al. 2019; Aghajani et
al. 2019; Beyer and Pinzger 2014; Barua et al. 2012; Rosen and
Shihab 2015; Cummaudo et al. 2020). SO, as a forum, maintains a
strict moderation policy, promotes a peer-reviewing mechanism,
and incorporates a reward system for encouraging quality answers
from the software developers (StackOverflow Reputation 2023).
Moreover, it has a vibrant user community and includes software
developers from all walks of life, experiences, etc. StackOverflow
Survey (2017). As a result, it offers a wealth of well-vetted
information on numerous software development topics. As such, SO
makes an excellent source for our study, as the primary goal of this
study is to derive ML contracts from peer-reviewed and well-vetted
content for the reliability of the findings. To capture the contracts,
analyzing the large code corpus of API usages (Wasylkowski et al.
2007; Nguyen et al. 2009; Khairunnesa et al. 2017) or the
implementation of the software itself Cousot et al. (2013) are both
well-known techniques. Our chosen methodology is closer to the
former (Fig. 1).
Fig. 1
Overview of the adopted methodology
Full size image
We used the SO forum’s tags to identify the relevancy of a post
to an ML library; if the question’s tag contained an ML library
name, it was considered a post related to that library and was thus a
candidate to be studied in this work.
Table 2 Dataset for Empirical Study on ML Contracts
Full size table
We ranked the top ML libraries using the frequency of these tags,
resulting in these four as the object of our study: TensorFlow, Scikitlearn, Keras, and PyTorch.
Next we filtered these posts based on a set of defined criteria
that are described in detail in §2.2.
The second and third authors (labelers), both with a strong
background in ML, were given background information on contract
literature. Then they were given hands-on training with sample SO
posts as described in §2.6.
After the training process, 10% of the filtered dataset is used by
the first three authors to develop the taxonomies used to label the
filtered posts. Two iterations were needed to propose the final
taxonomy presented here. The process is described in detail in §2.5.
Next, these labelers identified contracts implicitly present in
SO posts. We obtained 162, 122, 103, and 26 contracts, respectively,
from the previously curated posts. Table 2 shows a summary of the
dataset for each library in our study. For each SO question, we used
the taxonomy of contracts (including proposed categories) from
§2.3 to investigate the available information from the question and
accepted answer to decide the type of contract obligation missing in
the question and marked in the response. Hence, if the SO response
describes the correct way of using an API of interest violated in the
question, we identify that as a contract for the API that was
implicitly present in SO posts. We have also used the taxonomies
presented in §2.4 and §2.5 to complete the labeling in this stage. In
§2.3, we describe the process of identifying the contract violation
and potential contract for ML APIs with example SO posts from our
study. Then, the first author, with expertise (of approx. 6 years) in
contracts, reviewed the identified contracts and the SO post the
contracts were extracted from. This served two purposes: it ensured
that the identified contracts were correct and helped to reduce the
threat of missing contracts that was implicitly present in the
dataset from the second and third authors. The first author found
only a handful of contracts missed by these two labelers. However,
these missing contracts were found by at least one of the two
labelers. Therefore, we did not note any new contracts this way. If
one labeler identified a contract and the other did not, as they
performed their labeling using the proposed taxonomy, this was
identified as one of the reasons behind creating a conflict between
the two labelers. We discussed in §2.6 how we resolved the conflicts
in our study.
As the labeling process is completed, we analyze our labeled
dataset. Additionally, we have created a separately filtered dataset
(a subset of the original) based on the question scores and analyzed
questions with a relatively high score (in the range of 30-339). The
intuition behind further separating these posts is that an author
may ask one question, and only a handful of ML API users might
run into it. Then another SO question may be inquired by someone
but up-voted by hundreds of others who have the same problem.
Thus, the intuition behind further separating these filtered posts
was to understand how many ML API users are struggling with each
problem. This separate dataset was compared against the entire
dataset to be vigilant about the representative issues and respective
conclusions we draw from the posts in §3. This subset is selected
with the following criteria: select high-quality posts and keep
manual efforts manageable. To that end, to ensure high-quality
posts, we select posts having better than average scores (avg. 18.9).
To keep the manual effort manageable, we find a trade-off between
sample size and its statistical power. We specifically choose 30 as a
cut-off to have reasonable confidence in this additional study while
keeping manual efforts manageable (about 90% confidence level
with a 5% margin of error), resulting in 222 posts. We discarded
posts if they did not capture any information regarding correct
usage of ML APIs. Additionally, we grouped the discarded SO posts
that we could not label as containing contracts during the manual
curation step. We were unable to label some posts due to the
following reasons: posts asking general clarification questions,
unresolved issues with specific APIs of interest, an API unidentified
in a post, a solution involving tuning, or a dependency between an
unrelated API and a related API. For instance, in some of these
posts, the ML API users is usually curious about performing a task
at hand or inter-library code transformation and refactoring. To
illustrate, in one SO postFootnote1, the author is knowledgeable that
they can use the summary() API from Keras to print a model
summary. Yet, they want to know how to do the same using
Pytorch. Even if these posts are of interest to ML API users, these do
not fall into the category of contract requirements. In our study, the
number of total unlabelled posts is 1159, and the number of total
unlabelled posts with a score of or higher 30 is 161.
Finally we present our result in detail in §3. However, we did
not add the statistics for unlabeled posts in RQs, as these posts did
not unveil any ML contracts.

2.3 Classification of ML contracts and Violation Root Causes
To label the contracts for ML APIs found in our dataset, we
developed a classification scheme that categorizes different types
of contracts originating from these APIs.
As mentioned earlier, the literature mainly discusses two types of
contracts: behavioral and temporal.
Typically, behavioral contracts for APIs consist of assertions that
are required to be true before calling the API (preconditions) and
assertions that must be valid upon exiting the API method
(postconditions). In contrast, temporal contracts are those that
capture the required order of API calls to ensure proper behavior.
Both types of contracts are also observed in non-ML APIs, and we
build our classification on top of this well-established
classification. Building on an existing classification scheme helped
us to not reinvent known ideas (Glaser 1978) related to API
contracts. Student authors in this work used open coding to build
the extension appropriate for ML APIs.
Process
Researchers advocate using open coding to create any taxonomy
(Sarker et al. 2000); it is best that the researchers perform the task
themselves rather than rely on a third party. The authors worked as
a group initially to perform the coding and sampled 10% data to
that purpose. This strategy had several advantages, e.g., a
consistent decision to choose between existing concepts and create
a new one; categories became more exact while differences became
more evident than individually proposed taxonomy categories, and
it also provided an opportunity to properly train the two labelers.
We used axial coding (Corbin and Strauss 2008), a technique that
helps to collapse core themes involving qualitative data. In other
words, it organizes the codes developed during open coding. This
technique is used for cases where conceiving sub-categories seems
necessary for any central component inside the classification
schema. To elaborate, in our study, as we analyzed and labeled the
SO posts with identified contracts, we looked at how these subcategories could be grouped into central categories, so that the
central category could encompass a number of different posts. In
some cases, these central categories (axes) are from the state-ofthe-art taxonomy, e.g., data type-related contracts, but in other
cases, a new abstract category seemed appropriate, e.g., selection.
For instance, the codes such as Primitive Type, Built-in Type, etc.,
are well-established codes that describe different categories of
type-related contracts. We used axial coding to identify that these
contracts can be collapsed into the sub-core theme of checking
Data Type-related contracts. Similarly, we organized sub-core core
categories eventually into core categories. For instance, Data Type is
organized under the core category Single API Method. We further use
relational and variational sampling (Corbin and Strauss 1990) using
SO data to support or contradict the relationship between subcategories and core categories. These sampling techniques
facilitated explaining relations between theoretically relevant
categories through gathering data (depending on the frequency of
similarity or variation) on each group, e.g., considering conditions,
consequences, etc., on a case-by-case basis. For example, we
located instances of the leaf category MLtype in our dataset that
describes special type-related contracts that is only present in ML
APIs. The multiple samples we collected indicated that the reason
behind this contract violation is the input of an unacceptable input
type, and the effect, if explicitly present in the samples, is crash. The
frequency of such similarity confirmed the relationship between
the category MLtype and the category Data Type. This is an example
of relational sampling, precisely.
New Categories
We found four new categories during our initial study (marked with
in Table 3). After the initial study, the labelers individually
studied the rest of the posts and were at liberty to suggest
additional categories if the need arose (detail on labeling in §2.6).
The labelers conducted an in-person meeting under the
supervision of a moderator to discuss the suggested additional
categories and these reconciliation effort resulted in one additional
category (marked with in Table 3).
Classification Scheme
Next, we described our obtained classification schema in detail.
Furthermore, all categories included in this classification are
shown in Table 3. At the top level, we presented three central
contract component levels: contracts involving Single API Method,
contracts involving API Method Order, and contracts that required a
Hybrid of preceding categories. The first fundamental category,
Single API Method (SAM), in our classification scheme captures
preconditions/postconditions involving a single API method. This
core category is based on behavioral contracts. Next, MLAPIs often
require particular call orderings to demonstrate normal behavior;
we classify contracts specifying such order as API Method Order
(AMO). This category is based on temporal contracts. Subsequently,
we classified these categories into sub-classes until we could find a
leaf category that denoted the contract of a particular type for ML
APIs. For each such class, we explained the root cause of that
contract violation subsequently.
Table 3 Type of Contracts for MLAPIs (Symbols and at the
end of leaf components designate novel categories)
Full size table
2.3.1 Type of Contracts Involving Single API Method (SAM)
The first sub-category of Single API Method (SAM) contract
concerns type checking that is required Data Type (DT) of API
arguments.
This subclass consists of four types of contract:
Primitive Type (PT)
This represents the ML API argument type can be a primitive type,
e.g., float, int, bool, number, None, and the rest. For instance, in SO
post 1, the decode() method from the TensorFlowlibrary expects a
byte string. The root cause of this contract violation is an input of
an unacceptable type.
Stack Overflow post 1
Example post with contract
Stack Overflow post 2
Example post with contract
Built-in Type (BIT)
The contracts involving more complex built-in types (such as dict,
list, tuple, and array). For example, in SO post 2, concat() from the
TensorFlowlibrary expects the first argument to be of array type.
The root cause of this contract violation is an input of unacceptable
type.
Reference Type (RT)
This category of contracts can involve either internal class object,
i.e., referenced class objects within the API class, or external class
object, i.e., external variable referenced from separate modules of
the ML library. For example, in SO post 3, a contract for the API
KerasRegressor() from Kerasis shown. The argument accepts a
function, an instance of a class that implements the call method or
None. As the argument build_fn of this API accepts reference type
as one of its expected argument types, we classify this under the
reference type category. The root cause of this contract violation is
that an input of unacceptable type is supplied to the method.
Stack Overflow post 3
Example post with contract
ML Type (MT)
This final contract component of data type contains ML types. ML
types are a multidimensional array with a uniform type (float16,
float32, complex16, etc.), particularly designed for ML pipelines to
achieve accelerated performance (i.e., ease of use with GPU).
For instance, in SO post 4, an ML Type related contract is captured
stating that the matmul() API from the TensorFlowlibrary requires
that both of the arguments should be a Tensor with one of the
following types: float16, float32, float64, int32, complex64,
complex128.
Stack Overflow post 4
Example post with contract
Another example of this type of contract 5 is that the first two
arguments for the fit() API should have the type of a numpy array
or a list of numpy arrays. The root cause of this contract violation is
an input of unacceptable type supplied to the method. This post
also shows that the API has a supplementary contract concerning
argument dependency, as discussed below.
Stack Overflow post 5
Example post with contract
The API method can also involve Boolean assertions related to its
argument values, Boolean Expression Type (BET), instead of only
type related checks. We classify these types of contracts into two
subclasses:
Intra-argument contracts (IC-1)
IC-1 specifies preconditions related to a single argument of the API.
These contracts may involve both comparisons and logical
combinations.
Stack Overflow post 6
Example post with contract
An example of an IC-1 contract is given in SO post 6, which shows
an ML API users trying to use the TensorFlow API random_shuffle()
to shuffle a Tensor, a, with some set seed value. One of the
solutions mentioned in the accepted answer says that to do that,
one should specify the argument seed with the desired value, e.g.,
the argument seed gets the value 42. The root cause of this contract
violation is that acceptable input value is not supplied to (the
random_shuffle()) method.
Inter-argument contracts (IC-2)
IC-2 contracts involve more than one argument to an API method,
possibly using comparisons or logical expressions. For example, in
SO post 4, the matmul() API from TensorFlowrequires that the type
of the second argument should match the type of the first
argument. A comparison expression can express this contract, so it
belongs to IC-2. The root cause of this contract violation is that the
(matmul()) API is missing input value/type dependency between
arguments. Another example 7
for this category is nn.softmax_cross_entropy_with_logits(), an
API from TensorFlow, which requires that the logits and labels
arguments must have the same shape (i.e., [batch_size,
num_classes]).
Stack Overflow post 7
Example post with contract
2.3.2 Type of Contracts Involving API Method Order (AMO)
Multiple APIs can be involved in an AMO contract. There are two
sub-categories as follows:
Always (G)
Always contracts are AMO contracts that hold at each point of
history. For example, as shown in SO post 8, for TensorFlow, the call
to the method, tf.wholeFileReader() must be followed by another
method call, tf.train. start_queue_runners() to avoid hanging. The
root cause of this contract violation is that the always required
order between these calls is not followed.
Stack Overflow post 8
Example post with contract
Stack Overflow post 9
Example post with contract
Eventually (F)
Eventually contracts are AMO contracts where the ordering is only
required at some point in history. In other words, this specifies that
a required API ordering must be true at some point in this
program’s execution history far enough in the future. For instance,
in SO 9, the author is trying to solve a sequential classification
(input data where order matters) task. In the model, they used the
LSTM() API to return a sequence and then output it as a Dense()
object. The activation function has a one-to-one correspondence
with the type of classification being performed. For that reason, the
sigmoid function is rightly used. However, in the model, they used
the LSTM() API to return a sequence and then output it as a Dense()
object. This method order of APIs demonstrates an incorrect API
method order, as the order in the question post is missing a
TimeDistributed() API call.
Note that the code is correct for a many-to-one task in natural
language processing (NLP). However, in this question, the user asks
for a many-to-many solution, in which case it becomes mandatory
to apply TimeDistributed(). Therefore, using the TimeDistributed()
API only becomes a requirement after the LSTM() API is used to
return a sequence. The root cause of this contract violation is that
in a state where a call to a method (LSTM()) returns (a sequence),
another call to a method (TimeDistributed()) should have occurred.
Thus, in this 9, this eventually contract is violated because the
author did not know that the TimeDistributed() API is a
requirement to be called eventually after the LSTM() API is used to
return a sequence.
2.3.3 Type of Contracts Involving Hybrid (H) of SAM and AMO
The Hybrid (H) category involves a blend of behavioral and
temporal contracts. This category has two subclasses:
Stack Overflow post 10
Example post with contract
SAM-AMO Inter-dependency (SAI)
SAI contracts have a dependency between behavior and method
orders. This dependency could be in either direction, i.e., the
program’s state could determine the order of API calls, or the order
of API calls could require that some condition must hold. For
example, in 10, if an ML API users uses the SVM-based classifier
SVC as the estimator parameter for GridSearchCV() with Scikit-learn,
then preprocessing.scale() must precede this call. Since the order of
the method calls GridSearchCV() and preprocessing.scale() APIs is
dependent upon the value given to the parameter of
GridSearchCV(), it belongs to the SAI contract category. The root
cause of this contract violation is that the value being passed to one
method call (GridSearchCV()) requires a temporal ordering between
the two (GridSearchCV() and preprocessing.scale()) methods.
The leaf components of this subclass contain all contract cases that
we derived individually for the SAM and AMO categories. For
example, if an intra-argument contract, IC-1 of an API determines an
always (G), order of two APIs like the example above then, it belongs
to SAM (Level 3) ∧ AMO (Level 2).
Any dependency between SAM related leaf nodes, e.g., primitive
type, built-in type, ML type, etc. and AMO related leaf nodes, i.e., G
and F, belong to this category.
Selection (SL)
The final subclasses in our classification are those contracts that
involve a choice when it comes to enforcing an API related contract.
If the choices only belong to the contract components of SAM or
AMO, then we categorize the contracts into either SAM (Level 3) or
AMO (Level 2), respectively. For instance, in SO post 11, the author
wants to convert two numpy arrays to Tensors and uses
TensorDataset() from the PyTorchlibrary. The arguments of this API
must either be of Double or Float type. The API then confirms
DoubleTensor conversion upon exiting. Hence, there are two
choices of category SAM (specifically IC-2) to maintain the contract
for this API, and we mark this with SAM (Level 3) category. The
root cause of this contract violation is that the client did not follow
one of the two choices (providing arguments of Double or Float
types).
Stack Overflow post 11
Example post with contract
Another example can be seen in the SO post 12, where the author of
the post is using the Keraslibrary to create a neural network. Then
they want to initialize and fit the neural network weights and save
these weights. Next, they want to use these saved weights and
predict some output values given the inputs. However, they had
issues using the load_weights() API to collect the saved weights.
The answer post explains that as one uses the load_weights() API,
one has to maintain an order between two other related APIs
(compile and predict). One expected order is calling
load_weights(), compile(), predict(). The order alternative is
calling compile(), load_weights(), and predict() at some point in
history. As both choices involve AMO, this belongs to the AMO
(Level 2) category. The root cause of this contract violation is that
the client did not make one of the two choices (maintaining the
method order between the related APIs).
Stack Overflow post 12
Example post with contract
In comparison, if the choices involve both SAM and AMO, then we
categorize the contract as a combination type contract Comb. of
SAM and AMO. For example, in SO post 6, we observe such a
combination. The accepted answer respondent mentions two
alternative ways to maintain correctness when using the
tf.random_shuffle API. The first choice is setting the argument
seed for this API to some desired value. The second is maintaining
an order between invocations of tf.random_shuffle() and
tf.reset_default_graph(). Since the same contract breach can be
resolved through either a behavioral or temporal contract that
involves tf.random_shuffle() API, there is a selection involved as to
which one to be adopted. Documentation should include all choices
to maintain contracts for an API method. The root cause of this
contract violation is that the client did not make one of the two
choices (providing an acceptable seed value or using an acceptable
method ordering) for the API to function properly. Researchers
should emphasize the need to be able to express such requirements
to users, who can choose to satisfy the requirements of a library
either by maintaining a temporal order or by some state-based
change. Therefore, the practitioners can design and develop a
contract checking mechanism for ML API calling orders to facilitate
the end-users.
2.4 Classification of ML Contract Violation Locations
As we investigated the requirements for ML contracts, we also
classified the API locations of the contracts being violated.
We based this classification on prior works (Guo 2017; Islam et al.
2019), and used a similar open coding strategy as we did when
conceiving the classification for contract types. The categories are
explained in Table 4.
Table 4 Contract Violation Locations
Full size table
